# -*- coding: utf-8 -*-
"""06_Functions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QWJ6TuofhC15dbgXLu7rcaAjZYN_EbYy

#Function:
#User defined function
"""

#it is piece of code,jisko hum kuch input dete hain aur vo hame palat ke kuch output deta hain.
#it is used to increase code reusability.
#two core philosophies : 1]abstraction = Hota hain par dikhta nahi, ex] print function -> hota hain but hame uska code nahi dikhta. 2] decomposition = bahot sare functions ko milakar hi bada app/website banta hain.
#function components:
# 1] def -> keyword used to define function.
# 2] function_name -> try to give meaningful name.
# 3] (i) -> input to function
# 4] doc string(comment) ->added to explain functionality of code.documentation of string
# 5] function ka logic.
# 6] return statement/any other statement
# 7] function_name(input) -> used to call function
#

#how to access documentation of any function:
print(print.__doc__)

"""## Our first function:"""

#fuction ko banane ka code = function decleration
def is_even(num):
  """
  function kya karta hain vo batana hain.
  This function tell the given number is even or odd.
  input - ant valid integer.
  output - even or odd.
  created on - 13-09-2025.

  """
  if(num % 2 == 0):
    return "even"
  else:
    return 'odd'

#function ko use karne ka code = function call
for i in range(1,11):
  x=is_even(i)
  print(x)

"""## Two point of views:"""

#code banane wala(mostly senior developer) = agar code me kuch bhi error aaya to aapki galti hain bhaijaan! so try to write such code which will execute in any condition.
#code use karne wala(mostly junior developer) = tum kuchh bhi karo bhugtana to likhne wale ko hi hain.

#ex}
#fuction ko banane ka code = function decleration
def is_even1(num):
  """
  function kya karta hain vo batana hain.
  This function tell the given number is even or odd.
  input - ant valid integer.
  output - even or odd.
  created on - 13-09-2025.

  """
  if(type(num) == int):
    if(num % 2 == 0):
      return "even"
    else:
      return 'odd'
  else:
    print("Pagal hain kya  !  Sahi input enter kar na")

is_even1('Hello') # this is command from code use karne wala
#niche jo error aaya  ye banane wal ki galti hain use karne wale ki nahi.//tume kuch bhi lage banane wale ki hi galti hain.
#below command is output after modifying code.

is_even1('Hello')

"""## Argument vs Parameter:"""

# argument = function use karte time(function call) enter ki gayi value/any other thing
# parameter = function bante karte time(function decleration) enter ki gayi value/any other thing

#parameter = entity
#argument = entity ki value

"""## Types of argument:"""

#defalut argument :
#jaan bachane wala argument.
#agar user ne syantax chhod ke kuch bhi bheja to by default parameter ki value enter ho jayegi.

def power(a,b): # without default argument.
  return a**b

power(2,3)

power(2)

def power(a=1,b=1): # with default argument.
  return a**b

power(1)

power()

power(2,3)



#positional aegument:
#jis order me arguments bheje hain usi order me parameters ko receive honge.
#ex] 1 st wala argument jaygea 1 st wale parameter me.
#ex] 2 nd wala argument jaygea 2 nd wale parameter me.

power(2,3) # 2 jayega a me and 3 jayega b me.



#Keyword argument:

power(2,3)

power(3,2)

power(a=2,b=3)#it has more prcedence than positional argument.
#paramter ka naam ek keyword hain!

power(b=3,a=2)#more useful when your function which has too may parameter like ML ALGOs ex}DecisionTreeClassifier()



"""## *args and **kwargs:"""

# *args and **kwargs are special Python keywords that are used to pass the variable length of arguments to a function

# *args
# allows us to pass a variable number of non-keyword arguments to a function.

def multiply(*args):
  product = 1

  for i in args:
    product = product * i

  print(args)
  return product

multiply(1,2,3)

# **kwargs
# **kwargs allows us to pass any number of keyword arguments.
# Keyword arguments mean that they contain a key-value pair, like a Python dictionary.

def display(**kwargs):

  for (key,value) in kwargs.items():
    print(key,'->',value)

display(india='delhi',srilanka='colombo',nepal='kathmandu',pakistan='islamabad')

##### Points to remember while using `*args and **kwargs`

# - order of the arguments matter(normal -> `*args` -> `**kwargs`)
# - The words “args” and “kwargs” are only a convention, you can use any name of your choice

"""## How functions executes in memory:"""

# Lifespan of function(all varaibles in function) is between caling that function and returning the value.
#before an after it will not exists in memory.

##lifespan of varaible inside function = lifespan of function
# function act as independent program inside a program
# vo apna alag scope banayega and execute hone ke bad destroy bhi ho jayega.

"""## Function without return statement:"""

def is_even(num):
  if(num % 2 == 0):
    print("Even")

  else:
    print("odd")

# is_even(7)
print(is_even(7))

# if we dont use return function python by default returns None as return  value.
#interviw quetion.

l = [1,2,3,4]
print(l.append(5))
print(l)



"""## Varible Scoping:"""

#global varible = varaible used or delcread in program.(jo program ke andar hain but kisi function ke andar nahi hain)
#local varible = Varible used in function.(jo program ke andar hain and kisi function ke andar hain)

# function can use global varaible but main program can't use local varible
#you can make varible in both local global with same name.

#function can use global varible but can't change it.
#agar change karana hain to global varaible_name ye syntax hain but it is bad practice.

#interview me puch sakte hain.

def g(y):
    print(x)
    print(x+1)
x = 5
g(x)
print(x)

def f(y):
    x = 1
    x += 1
    print(x)
x = 5
f(x)
print(x)

def h(y):
    x += 1
x = 5
h(x)
print(x)

#to deal with above problem
def h(y):
  global x
  x += 1
x = 5
h(x)
print(x)

def f(x):
   x = x + 1
   print('in f(x): x =', x)
   return x

x = 3
z = f(x)
print('in main program scope: z =', z)
print('in main program scope: x =', x)

#infinite loop
def f():
  def g():
    print('inside function g')
    f()
  g()
  print('inside function f')

"""## Nested functions:"""

#you can't acces nested function from main program .
#you can use nested function to hide logic(secret code)
#use python tutor for visualisation.

def g(x):
    def h():
        x = 'abc'
    x = x + 1
    print('in g(x): x =', x)
    h()
    return x

x = 3
z = g(x)

def g(x):
    def h():
        x = 'abc'
    x = x + 1
    print('in g(x): x =', x)
    h()
    return x

x = 3
z = g(x)

def g(x):
    def h(x):
        x = x+1
        print("in h(x): x = ", x)
    x = x + 1
    print('in g(x): x = ', x)
    h(x)
    return x

x = 3
z = g(x)
print('in main program scope: x = ', x)
print('in main program scope: z = ', z)

"""## Functions are the first class citizen:"""

# first class citizen = mainly all data types
# but in python function is also first class citizen
#it can act like data type
#agar integer kar sakta hain to function bhi kar sakta hain.
# function vo sabkuch kar sakta hain jo ek datatype kar sakta hain.
# first class citizen = jispar sare operatons perform ho sakte hain.like delete,add,store.

def square(num):
  return num**2

# type and id

print(type(square))

id(square)

# reassign
x = square
id(x)
x(3)

a = 2
b = a
b

# deleting a function
del square

square(3)

# storing
L = [1,2,3,4,square]
print(L)

L[-1](3)

#immutable
s = {square}
s

#returning a function
def f():
    def x(a, b):
        return a+b
    return x

val = f()(3,4)
print(val)

#you can acess nested function from main program if main function returns nested function.
#as we get in return list,tuple,string,int same like that we get function.

# function as argument
def func_a():
    print('inside func_a')

def func_b(z):
    print('inside func_c')
    return z()

print(func_b(func_a))

"""## benefits of using function:"""

# - Code Modularity -> divide whole code in different module. ex] login ka alag code,search ka alag code.
# - Code Readibility -> agar team me kaam kar arhe ho to sabke pass ek copy ho sakti hain.readbility badhegi.
# - Code Reusability -> aapko to pata hi hain.

"""## lambda function:"""

# A lambda function is a small anonymous(jiska nam nahi hota) function.
# A lambda function can take any number of arguments, but can only have one expression.

# x -> x^2
lambda x:x**2

# x -> x^2
a = lambda x:x**2
a(3)

# x,y -> x+y
a = lambda x,y:x+y
a(5,2)

# #### Diff between lambda vs Normal Function

# - No name
# - lambda has no return value(infact,returns a function)
# - lambda is written in 1 line
# - not reusable

# Then why use lambda functions?
# **They are used with HOF**

# check if a string has 'a'
a = lambda s:'a' in s
a('hello')

# odd or even
a = lambda x:'even' if x%2 == 0 else 'odd'
a(6)



"""## Higher order functions:"""

#the function which take another function as input or return a function as output.

def square(x):
  return x**2

def cube(x):
  return x**3

# HOF
def transform(f,L):
  output = []
  for i in L:
    output.append(f(i))

  print(output)

L = [1,2,3,4,5]

transform(lambda x:x**3,L)

# map ()

# square the items of a list
list(map(lambda x:x**2,[1,2,3,4,5]))

# odd/even labelling of list items
L = [1,2,3,4,5]
list(map(lambda x:'even' if x%2 == 0 else 'odd',L))

# fetch names from a list of dict

users = [
    {
        'name':'Rahul',
        'age':45,
        'gender':'male'
    },
    {
        'name':'Nitish',
        'age':33,
        'gender':'male'
    },
    {
        'name':'Ankita',
        'age':50,
        'gender':'female'
    }
]

list(map(lambda users:users['gender'],users))



#filter:

# numbers greater than 5
L = [3,4,5,6,7]

list(filter(lambda x:x>5,L))

# fetch fruits starting with 'a'
fruits = ['apple','guava','cherry']

list(filter(lambda x:x.startswith('a'),fruits))



#reduce:

# sum of all item
import functools

functools.reduce(lambda x,y:x+y,[1,2,3,4,5])

# find min
functools.reduce(lambda x,y:x if x>y else y,[23,11,45,10,1])

