# -*- coding: utf-8 -*-
"""09_OOps Part-3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ENWF4EEgsMgzE1ziSR3_P5yzsb7_JPUl
"""

## Relationships
# 1.Aggregation
# 2.Inheritance

"""## Aggregation:"""

#A class owns another class
#Ek owner hoga and second uski property hoga.
#Has a relationship = aggregation -> customer has address
#Owner class can't acess private attributes of owned class
#Owner class ke obj me owned class ka object bhej dena.

class Person:
    def __init__(self,name,gender,address):
        self.name = name
        self.gender = gender
        self.address = address


    def print_address(self):
        print(self.address.state,self.address.get_pincode(),self.address.city)

    def edit_profile(self,new_name,new_city,new_pin,new_state):
        self.name = new_name
        self.address.edit_address(new_city,new_pin,new_state)


class Address:
    def __init__(self,state,pincode,city):
        self.state = state
        self.__pincode = pincode
        self.city = city

    def edit_address(self,new_city,new_pin,new_state):
        self.city=new_city
        self.__pin = new_pin
        self.state = new_state


    def get_pincode(self):
          return self.__pin

add = Address('up',415111,'Delhi')
p = Person('Raj','Male',add)

p.print_address() # how to get address by using get method

p.edit_profile('Vardan','Karad',411111,'Mh')



"""## Inheritance"""

# Jo baap ka vo bete ka
# ek child class hoga and ek parent class hoga and child class parent class ke sare attributes and objects ko access kar sakta hain!
#Benifit = Code reusability
#Don't violate dry(don't repeat yourselve principle)
#ek baar likho bar bar use karo!

class User:

    def __init__(self):
        self.name = "Raj"

    def login(self):
        print("Login")

class Student(User):

    # def __init__(self):
    #     self.rollNo = 2317061

    def enroll(self):
        print("Tumhara bhi catega!")

u = User()
s = Student()

s.name

# Why above error:
# jab child class ka object banta hain to automatically constructor execute hota hain.to is case me bhi constructor execute hua.
# jab s.name execute karne ja rahin to vo apne costructor mr dhundh raha hain ,ha bhai kaha hain name jo use nahi mila ,use error diya

# jab child ka constructor execute hoga to vo parent ka dekhega bhi nahi agar uska constructor hain hi nahi tabhi vo papa ka constructor dekhega

s.login()

# s.rollNo

s.enroll()



# Inheritance and it's benefits

# Example

# parent
class User:

  def __init__(self):
    self.name = 'nitish'
    self.gender = 'male'

  def login(self):
    print('login')

# child
class Student(User):

  def __init__(self):
    self.rollno = 100

  def enroll(self):
    print('enroll into the course')

u = User()
s = Student()

# print(s.name) # Kyunki u ka constructor call hi nahi hua
s.login()
s.enroll()

# Class diagram















##Whats are inherited?

# - Constructor
# - Non Private Attributes
# - Non Private Methods

# 1]constructor

# 1.agar child ke padd khud ka constructor nahi hain to parent ka constructor call hoga
# 2.agar child ka constructor hain to parent ka call hoga bhi nahi , agar call nahi hua to uske under ke varaibles initialize hi nahi honge,
# agar initialize hi nahi huye to child class unhe access nahi kar sakta
#3.Can't acces private members(attributes/methods) of parent class

# constructor example

class Phone:
    def __init__(self, price, brand, camera):
        print ("Inside phone constructor")
        self.price = price
        self.brand = brand
        self.camera = camera

    def buy(self):
        print ("Buying a phone")

class SmartPhone(Phone):
    pass

s=SmartPhone(20000, "Apple", 13)
s.buy()

# constructor example 2

class Phone:
    def __init__(self, price, brand, camera):
        print ("Inside phone constructor")
        self.__price = price
        self.brand = brand
        self.camera = camera

class SmartPhone(Phone):
    def __init__(self, os, ram):
        self.os = os
        self.ram = ram
        print ("Inside SmartPhone constructor")

s=SmartPhone("Android", 2)
s.brand

# child can't access private members of the class

class Phone:
    def __init__(self, price, brand, camera):
        print ("Inside phone constructor")
        self.__price = price
        self.brand = brand
        self.camera = camera

    #getter
    def show(self):
        print (self.__price)

class SmartPhone(Phone):
    def check(self):
        print(self.__price)

s=SmartPhone(20000, "Apple", 13)
s.show()

class Parent:

    def __init__(self,num):
        self.__num=num

    def get_num(self):
        return self.__num

class Child(Parent):

    def show(self):
        print("This is in child class")

son=Child(100)
print(son.get_num())
son.show()

class Parent:

    def __init__(self,num):
        self.__num=num

    def get_num(self):
        return self.__num

class Child(Parent):

    def __init__(self,val,num):
        self.__val=val

    def get_val(self):
        return self.__val

son=Child(100,10)
print("Parent: Num:",son.get_num())
print("Child: Val:",son.get_val())

class A:
    def __init__(self):
        self.var1=100

    def display1(self,var1):
        print("class A :", self.var1)
class B(A):

    def display2(self,var1):
        print("class B :", self.var1)

obj=B()
obj.display1(200)



"""## Method Overloading"""

#If in both parent and child class contain method with same name then child class method will execute that's known as method overloading

# Method Overriding
class Phone:
    def __init__(self, price, brand, camera):
        print ("Inside phone constructor")
        self.__price = price
        self.brand = brand
        self.camera = camera

    def buy(self):
        print ("Buying a phone")

class SmartPhone(Phone):
    def buy(self):
        print ("Buying a smartphone")

s=SmartPhone(20000, "Apple", 13)

s.buy()



"""## Super Keyword"""

# 1) self,2)static 3)super -> most imp words in python

# #super() is the way to access parenet ke methods
# super() is always written inside the class specially child class -> bahar se call nahi hoga
# super can't access sttributes

class Phone:
    def __init__(self, price, brand, camera):
        print ("Inside phone constructor")
        self.__price = price
        self.brand = brand
        self.camera = camera

    def buy(self):
        print ("Buying a phone")

class SmartPhone(Phone):
    def buy(self):
        print ("Buying a smartphone")
        # syntax to call parent ka buy method
        super().buy()

s=SmartPhone(20000, "Apple", 13)

s.buy()

# using super outside the class
class Phone:
    def __init__(self, price, brand, camera):
        print ("Inside phone constructor")
        self.__price = price
        self.brand = brand
        self.camera = camera

    def buy(self):
        print ("Buying a phone")

class SmartPhone(Phone):
    def buy(self):
        print ("Buying a smartphone")
        # syntax to call parent ka buy method
        super().buy()

s=SmartPhone(20000, "Apple", 13)

s.buy()

# can super access parent ka data?
# using super outside the class
class Phone:
    def __init__(self, price, brand, camera):
        print ("Inside phone constructor")
        self.__price = price
        self.brand = brand
        self.camera = camera

    def buy(self):
        print ("Buying a phone")

class SmartPhone(Phone):
    def buy(self):
        print ("Buying a smartphone")
        # syntax to call parent ka buy method
        print(super().brand)

s=SmartPhone(20000, "Apple", 13)

s.buy()

# super -> constuctor
class Phone:
    def __init__(self, price, brand, camera):
        print ("Inside phone constructor")
        self.__price = price
        self.brand = brand
        self.camera = camera

class SmartPhone(Phone):
    def __init__(self, price, brand, camera, os, ram):
        print('Inside smartphone constructor')
        super().__init__(price, brand, camera)
        self.os = os
        self.ram = ram
        print ("Inside smartphone constructor")

s=SmartPhone(20000, "Samsung", 12, "Android", 2)

print(s.os)
print(s.brand)



# ##### Inheritance in summary

# - A class can inherit from another class.

# - Inheritance improves code reuse

# - Constructor, attributes, methods get inherited to the child class

# - The parent has no access to the child class

# - Private properties of parent are not accessible directly in child class

# - Child class can override the attributes or methods. This is called method overriding

# - super() is an inbuilt function which is used to invoke the parent class methods and constructor

#Exampales

class Parent:

    def __init__(self,num):
      self.__num=num

    def get_num(self):
      return self.__num

class Child(Parent):

    def __init__(self,num,val):
      super().__init__(num)
      self.__val=val

    def get_val(self):
      return self.__val

son=Child(100,200)
print(son.get_num())
print(son.get_val())

class Parent:
    def __init__(self):
        self.num=100

class Child(Parent):

    def __init__(self):
        super().__init__()
        self.var=200

    def show(self):
        print(self.num)
        print(self.var)

son=Child()
son.show()

class Parent:
    def __init__(self):
        self.__num=100

    def show(self):
        print("Parent:",self.__num)

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__var=10

    def show(self):
        print("Child:",self.__var)

obj=Child()
obj.show()

class Parent:
    def __init__(self):
        self.__num=100

    def show(self):
        print("Parent:",self.__num)

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__var=10

    def show(self):
        print("Child:",self.__var)

obj=Child()
obj.show()



# # Types of Inheritance

# - Single Inheritance
# - Multilevel Inheritance
# - Hierarchical Inheritance
# - Multiple Inheritance(Diamond Problem)
# - Hybrid Inheritance

# single inheritance
class Phone:
    def __init__(self, price, brand, camera):
        print ("Inside phone constructor")
        self.__price = price
        self.brand = brand
        self.camera = camera

    def buy(self):
        print ("Buying a phone")

class SmartPhone(Phone):
    pass

SmartPhone(1000,"Apple","13px").buy()

# multilevel
class Product:
    def review(self):
        print ("Product customer review")

class Phone(Product):
    def __init__(self, price, brand, camera):
        print ("Inside phone constructor")
        self.__price = price
        self.brand = brand
        self.camera = camera

    def buy(self):
        print ("Buying a phone")

class SmartPhone(Phone):
    pass

s=SmartPhone(20000, "Apple", 12)

s.buy()
s.review()

# Hierarchical
class Phone:
    def __init__(self, price, brand, camera):
        print ("Inside phone constructor")
        self.__price = price
        self.brand = brand
        self.camera = camera

    def buy(self):
        print ("Buying a phone")

class SmartPhone(Phone):
    pass

class FeaturePhone(Phone):
    pass

SmartPhone(1000,"Apple","13px").buy()
FeaturePhone(10,"Lava","1px").buy()

# Multiple
class Phone:
    def __init__(self, price, brand, camera):
        print ("Inside phone constructor")
        self.__price = price
        self.brand = brand
        self.camera = camera

    def buy(self):
        print ("Buying a phone")

class Product:
    def review(self):
        print ("Customer review")

class SmartPhone(Phone, Product):
    pass

s=SmartPhone(20000, "Apple", 12)

s.buy()
s.review()

# the diamond problem
# https://stackoverflow.com/questions/56361048/what-is-the-diamond-problem-in-python-and-why-its-not-appear-in-python2
class Phone:
    def __init__(self, price, brand, camera):
        print ("Inside phone constructor")
        self.__price = price
        self.brand = brand
        self.camera = camera

    def buy(self):
        print ("Buying a phone")

class Product:
    def buy(self):
        print ("Product buy method")

# Method resolution order
class SmartPhone(Phone,Product): # jo pehle likha hua hain uska method execute hoga
    pass

s=SmartPhone(20000, "Apple", 12)

s.buy()

class A:

    def m1(self):
        return 20

class B(A):

    def m1(self):
        return 30

    def m2(self):
        return 40

class C(B):

    def m2(self):
        return 20
obj1=A()
obj2=B()
obj3=C()
print(obj1.m1() + obj3.m1()+ obj3.m2())

class A:

    def m1(self):
        return 20

class B(A):

    def m1(self):
        val=super().m1()+30
        return val

class C(B):

    def m1(self):
        val=self.m1()+20
        return val
obj=C()
# print(obj.m1()) recursion hoga



"""## Polymorphism"""

# ### Polymorphism

# - Method Overriding
# - Method Overloading
# - Operator Overloading

class Shape:

  def area(self,a,b=0):
    if b == 0:
      return 3.14*a*a
    else:
      return a*b

s = Shape()

print(s.area(2))
print(s.area(3,4))

'hello' + 'world'

4 + 5

[1,2,3] + [4,5]



from abc import ABC,abstractmethod
class BankApp(ABC):

  def database(self):
    print('connected to database')

  @abstractmethod
  def security(self):
    pass

  @abstractmethod
  def display(self):
    pass

class MobileApp(BankApp):

  def mobile_login(self):
    print('login into mobile')

  def security(self):
    print('mobile security')

  def display(self):
    print('display')

mob = MobileApp()

mob.security()

obj = BankApp()

