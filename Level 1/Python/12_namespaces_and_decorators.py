# -*- coding: utf-8 -*-
"""12_Namespaces and Decorators.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jTn8ALNJmspk4wskSvXa3Ma6EoA9Kch7

### Namespaces

A namespace is a space that holds names(identifiers).Programmatically speaking, namespaces are dictionary of identifiers(keys) and their objects(values)

There are 4 types of namespaces:
- Builtin Namespace
- Global Namespace
- Enclosing Namespace
- Local Namespace

### Scope and LEGB Rule

A scope is a textual region of a Python program where a namespace is directly accessible.

The interpreter searches for a name from the inside out, looking in the local, enclosing, global, and finally the built-in scope. If the interpreter doesnâ€™t find the name in any of these locations, then Python raises a NameError exception.
"""

# local and global
# global var
a = 2

def temp():
  # local var
  b = 3
  print(b)

temp()
print(a)

# local and global -> same name
a = 2

def temp():
  # local var
  a = 3
  print(b)

temp()
print(a)

# local and global -> local does not have but global has
#Local can access global but global can't access local
a = 2

def temp():
  # local var
  print(a)

temp()
print(a)

# local and global -> editing global
#you can use or print global inside local but you can't edit it.
#You can't directly edit global var from local space
a = 2

def temp():
  # local var
  a += 1
  print(a)

temp()
print(a)

#But you can do that with the help pf global keyword
#Don't use it it is bad practice.
#Jab aap real project par kam karo and usme bahot sare functions hain and vo global var pe dependent hain.
#to ek function me se global ko  change karne se baki saro me unexpected results aa sakte hain.
a = 2

def temp():
  # local var
  global a
  a += 1
  print(a)

temp()
print(a)

# local and global -> global var  created from  local space
# Ho sakta hain magar karana nai!
# Bad practice.
def temp():
  # local var
  global a
  a = 1
  print(a)

temp()
print(a)

# local and global -> function parameter is local var
# You can't use or access local var outside local space .
def temp(z):
  # local var
  print(z)

a = 5
temp(5)
print(a)
print(z)

# built-in
#Jise app use karto ho bina kuch code likhe.like int , float,input() like that.

# how to see all the built-ins
import builtins
print(dir(builtins))

# renaming built-ins
#If you are using built in functions name as global name then it will give priority to gobal one
#override built in
L = [1,2,3]
print(max(L))
def max():
  print('hello')

print(max(L))

# Enclosing scope
def outer():
  def inner():
    print(a)
  inner()
  print('outer function')


outer()
print('main program')

# nonlocal keyword
def outer():
  a = 1
  def inner():
    nonlocal a
    a += 1
    print('inner',a)
  inner()
  print('outer',a)


outer()
print('main program')

# Summary

"""### Decorators

A decorator in python is a function that receives another function as input and adds some functionality(decoration) to and it and returns it.

This can happen only because python functions are 1st class citizens.

There are 2 types of decorators available in python
- `Built in decorators` like `@staticmethod`, `@classmethod`, `@abstractmethod` and `@property` etc
- `User defined decorators` that we programmers can create according to our needs
"""

# Python are 1st class function

def modify(func,num):
  return func(num)

def square(num):
  return num**2

modify(square,2)

# simple example
#Function jab return statment deata hain/uske under ki sari cheeje execute karata hain tab vo marta hain(all varaibles anf function itself removes from memory).
#But in decorator case it won't happen beacause ,decorator is a function which take a function as input and returns the function as output

def my_decorator(func):
  def wrapper():
    print('***********************')
    func()
    print('***********************')
  return wrapper

def hello():
  print('hello')

a = my_decorator(hello)
a()

# more functions

# how this works -> closure?
#Function jab return statment deata hain/uske under ki sari cheeje execute karata hain tab vo marta hain(all varaibles anf function itself removes from memory).
#But in decorator case it won't happen beacause ,decorator is a function which take a function as input and returns the function as output
#iski ko closure kehte hain

# python tutor
#gary ho jata hain ,hatata nahi hain!

# Better syntax?
# simple example
#upar wala and ye same example ahin with different syntax

def my_decorator(func):
  def wrapper():
    print('***********************')
    func()
    print('***********************')
  return wrapper

@my_decorator
def hello():
  print('hello')

hello()

# anything meaningful?
import time
#func.__name__ -->used to print function's actual name
#need to add @decorator name at top of ech function if you want to apply decorator

def timer(func):
  def wrapper(*args):
    start = time.time()
    func(*args)
    print('time taken by',func.__name__,(time.time()-start),'secs')
  return wrapper

@timer
def hello():
  print('hello wolrd')
  time.sleep(2)

@timer
def square(num):
  time.sleep(1)
  print(num**2)

@timer
def power(a,b):
  print(a**b)

@timer
def king():
  print("what if code ruptures?")

hello()
king()
square(2)
power(2,3)

# A big problem

# One last example -> decorators with arguments

@checkdt(int)
def square(num):
  print(num**2)

def sanity_check(data_type):
  def outer_wrapper(func):
    def inner_wrapper(*args):
      if type(*args) == data_type:
        func(*args)
      else:
        raise TypeError('Ye datatype nai chalega')
    return inner_wrapper
  return outer_wrapper

@sanity_check(int)
def square(num):
  print(num**2)

@sanity_check(str)
def greet(name):
  print('hello',name)

square(2)

