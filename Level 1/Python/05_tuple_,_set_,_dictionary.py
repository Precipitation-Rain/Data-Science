# -*- coding: utf-8 -*-
"""05 - Tuple , Set , Dictionary.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11GfUQ_kKJf6wvYwhdkvW5k8mU7woxRGb

# Tuple
"""

# List ka bhai
# 2 big diff:
  # 1.immutable
  # 2.closed inside ()
#almost similar

"""## Creating a tuple"""

#empty
t=()
print(t)

#tuple wiht one elment : special case
# t1 =(1) # this will create an integer.
# print(t1)
# print(type(t1))

t1 =(1,) # this is right syntax
print(t1)
print(type(t1))

#homogenous
t3 = (1,2,3,4)
print(t3)

#hetrogenous
t4 = (1,2.2,'Hello',True,[1,2,3])
print(t4)

#2d
t5 = (1,2,True,(4,5))
print(t5)

#3d : bahar se andar brackets gino .jitne bracket (((( )))) utne dimension ka tuple
t6 = (1,2,True,(4,5,(7,8,'king',4+3j)))
print(t6)

#type conversio
t7 = tuple('king')
print(t7)

"""## Access items from tuple"""

# all is same like list
#agar mujhe list me aata hain to me yaha bhi kar lunga

#indexing
print(t3)
t3[1]
t3[-1]

#slicing
print(t3)
print(t3[0:3])
print(t3[0:])
print(t3[-3:])
print(t3[0:4:2])

# to reverse tuple
t3[::-1]

t6

print(t6[3][2][2])

"""## Editing items in tuple"""

print(t3)
t3[0] = 1000
#tuple is immutable.Ek bar ban gaya to usme change nahi kar sakte

"""## Adding items in tuple"""

#not possible

"""## Deleting items from tuple"""

#you can delete whole tuple but can delete single/muliple items

print(t3)

del t3
print(t3)

print(t3)
del t3[3]

"""## Operations on tuple"""

#Arithemetic
t1 = (1,2,3,4)
t2 = (5,6,7,8)

t1+t2

t1*2



#membership
1 in t1

4 not in t2



#loops

for i in t1:
  print(i)

"""##Functions of tuple"""

t = (1 , 2 , 3 , 4 , 5)

len(t)

min(t)

max(t)

sum(t)

sorted(t) # always return a list .In also case of string

"""##Difference between List and Tuple:"""

#Syntax:
# list = [1,2,3,4,5]
# tuple = (1,2,3,4,5)

#Mutatability:
#list = mutable
#tuple = immutable

#speed:
#list = slow
#tuple = fast

#memoty:
#list = more memory
#tuple = less memory

#built in functionality:
#list = more
#tuple = less

#Error prone
#list = more
#tuple = less

#usability
#list = more
#tule = less

"""## Special syntax:"""

#tuple unpacking:
a,b,c,= (1,2,3)
print(a,b,c)

a,b,c = (1,2,3,4)
print(a,b,c)

a,b = 1,2
print(a,b)
a,b = b,a
print(a,b)

a,b,*others = (1,2,3,4,5)
print(a,b,others)

"""## zip function:"""

a = (1,2,3)
b = (4,5,6)

tuple(zip(a,b))











"""# Set"""

#unordered
#mutable
#no duplicates
# items must be immutable

"""## Creating a set:"""

#empty:
s = {} # this will create empty dictionary
print(type(s))

s1 = set() # this will create empty set
print(type(s1))

#no 2d or nd sets allowed only 1d allowed
# 1d
s = {1,2,3,4}
print(s)

# 2d/nd:
s={1,2,3,{1,2,3}}
print(s)

# duplicated not aloowed:
s = {1,2,3,3,2,1}
print(s)

#homogenouse:
s={1,2.2,'hello',True,(2,3,4)}
print(s)

# using type conversion:
s = set([1,2,3])
print(s)

#set can't have mutable items:
m={1,2,3,{4,5,6}}
print(m)

#order does not matter:
#who decides order -> internal algorithm hashing
a = {1,2,3}
b = {3,2,1}
a == b

"""## Accesing items:"""

# you can't access items,becaz it is unordered



"""## Editing item:"""

#if you dont access item then you dont edit items



"""## Adding items:"""

s = {1,2,3,4,5}

# add() : add only one item to position which is decided by hashing algo
s.add(6)
print(s)

#update : add multiple items to position which is decided by hashing algo
s.update([4,7,8,9])
print(s)

"""## Deleting items:"""

#del
s = {1,2,3}
del s

print(s)

#discard():
s.discard(5) # delete item that we give
print(s)

s.discard(50) # if we delete such an item which not exist in set then it will don't give any error
print(s)

#remove():delete item that we give
print(s)
s.remove(4)
print(s)

#pop() : randomly delete ant item:
s = {1,2,3,4,5,6,7,8,9,0}
print(s) # generally remove first item
s.pop()
print(s)
a =s.pop()
print(s,a)

#clear:delete all elements of set but not set
print(s)
s.clear()
print(s)

"""## Operations on set:"""

s1 = {1,2,3,4,5}
s2 = {3,4,5,6,7}

#unioun:
print(s1 | s2)

#intersection:
print(s1 & s2)

#difference:
print(s1 - s2)
print(s2 - s1)

#symmetric difference:
print(s1 ^ s2)

#membership:
s2 = {3,4,5,6,7}
3 in s2
4 not in s2

#loops
for i in s2:
  print(i)

"""##functions:"""

s2 = {3,4,5,6,7}

print(len(s2))

print(min(s2))

print(max(s2))

print(sum(s2))

print(sorted(s2))

print(sorted(s2,reverse = True))

#intersection/update
# union/update
s1 = {1,2,3,4,5}
s2 = {4,5,6,7,8}

# s1 | s2
s1.union(s1) # calculate unioun

s1.update(s2) #calculate unioun and store in s1
print(s1)
print(s2)

#intersection/intersection_update
s1 = {1,2,3,4,5}
s2 = {4,5,6,7,8}

s1.intersection(s2) # calculate intersection

s1.intersection_update(s2)#calculate intersection and store in s1
print(s1)
print(s2)

# difference/difference_update
s1 = {1,2,3,4,5}
s2 = {4,5,6,7,8}

s1.difference(s2) # calculate difference

s1.difference_update(s2)#calculate difference and store in s1
print(s1)
print(s2)

# symmetric_difference/symmetric_difference_update
s1 = {1,2,3,4,5}
s2 = {4,5,6,7,8}

s1.symmetric_difference(s2)#calculate symmetric_difference

s1.symmetric_difference_update(s2)#calculate symmetric_difference and store in s1
print(s1)
print(s2)

# isdisjoint/issubset/issuperset/copy
s1 = {1,2,3,4}
s2 = {7,8,5,6}

s1.isdisjoint(s2)

s1 = {1,2,3,4,5}
s2 = {3,4,5}

s1.issuperset(s2)

s1 = {1,2,3,4,5}
s2 = {3,4,5}

s1.issubset(s2)

# copy
s1 = {1,2,3}
s2 = s1.copy()

print(s1)
print(s2)

"""##Frozen set:"""

#Frozen set is just an immutable version of a Python set

# create frozenset
fs1 = frozenset([1,2,3])
fs2 = frozenset([3,4,5])

fs1 | fs2

# what works and what does not
# works -> all read functions
# does't work -> write operations

# When to use
# 2D sets
fs = frozenset([1,2,frozenset([3,4])])
fs

"""## Set comprehension:"""

#same as list and tuple comprehension

{i**2 for i in range(1,11) if i>5}

"""#Dictionary"""

# Dictionary

# Dictionary in Python is a collection of keys values, used to store data values like a map, which, unlike other data types which hold only a single value as an element.

# In some languages it is known as map or assosiative arrays.

# dict = { 'name' : 'nitish' , 'age' : 33 , 'gender' : 'male' }

# Characterstics:

# - Mutable
# - Indexing has no meaning
# - keys can't be duplicated
# - keys can't be mutable items

"""## Creating a dictionary:"""

# empty dictionary
d = {}
d

# 1D dictionary
d1 = { 'name' : 'nitish' ,'gender' : 'male' }
d1

# with mixed keys
d2 = {(1,2,3):1,'hello':'world'}
d2

# 2D dictionary -> JSON
s = {
    'name':'nitish',
     'college':'bit',
     'sem':4,
     'subjects':{
         'dsa':50,
         'maths':67,
         'english':34
     }
}
s

# using sequence and dict function
d4 = dict([('name','nitish'),('age',32),(3,3)])
d4

# duplicate keys : last key wala reh jayega baki hat jeyenge
d5 = {'name':'nitish','name':'rahul'}
d5

# mutable items as keys
d6 = {'name':'nitish',[1,2,3]:2}
print(d6)

"""##Accesing items from dictionary:"""

my_dict = {'name': 'Jack', 'age': 26}
# []
my_dict['age']

# get
my_dict.get('age')

#how to access from nested dictionay:
s['subjects']['maths']

"""##Adding item in dictionary:"""

print(d4)

d4['gender'] = 'male'
d4
d4['weight'] = 72
d4

print(s)

#adding in nested dictionary:
s['subjects']['ds'] = 75
s

"""##Remove key-value pair from dict:"""

d = {'name': 'nitish', 'age': 32, 3: 3, 'gender': 'male', 'weight': 72}
d

#pop : delete item which key we give
d.pop(3)
print(d)


# clear
d.clear()
print(d)

#popitem() : remove last key value pait
d.popitem()
d.popitem()
print(d)



print(d)

#del : we can delete whole dict or any key-value pair also
del d['name']
print(d)

s={'name': 'nitish', 'college': 'bit', 'sem': 4, 'subjects': {'dsa': 50, 'maths': 67, 'english': 34, 'ds': 75}}

print(s)

# #deleting from nested dict:
del s['subjects']['maths']
print(s)

"""## Editing key-value pair:"""

s

#1d
s['name'] = 'Raj'
s



#2d
s['subjects']['dsa'] = 80
s

"""##Dictiory operations:"""

d = {'name':'nitish','gender':'male','age':33}
print(d)

'name' in d

d = {'name':'nitish','gender':'male','age':33}

for i in d:
  print(i,d[i])

"""## Dicttionary Functions"""

d = {'name':'nitish','gender':'male','age':33}

# len/sorted

# len/sorted
len(d)

sorted(d,reverse=True)

max(d)

min(d)



# items/keys/values

print(d)

print(d.items())
print(d.keys())
print(d.values())

# update
d1 = {1:2,3:4,4:5}
d2 = {4:7,6:8}

d1.update(d2)
print(d1)



"""## Dictionary Comprehension"""

# print 1st 10 numbers and their squares
{i:i**2 for i in range(1,11)}

distances = {'delhi':1000,'mumbai':2000,'bangalore':3000}
print(distances.items())

# using existing dict
distances = {'delhi':1000,'mumbai':2000,'bangalore':3000}
{key:value*0.62 for (key,value) in distances.items()}

# using if condition
products = {'phone':10,'laptop':0,'charger':32,'tablet':0}

{key:value for (key,value) in products.items() if value>0}

# Nested Comprehension
# print tables of number from 2 to 4
{i:{j:i*j for j in range(1,11)} for i in range(2,5)}

"""## Zip function"""

# using zip
days = ["Sunday", "Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]
temp_C = [30.5,32.6,31.8,33.4,29.8,30.2,29.9]

{i:j for (i,j) in zip(days,temp_C)}

"""## Special Syntax"""









