# -*- coding: utf-8 -*-
"""08_OOps Part2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G6aalx4LZ6QcGE6yxwwCreLTPCCLzKmt

## Revision Of Last Class
"""

class Point:
    def __init__(self,x,y):
        self.x_cod = x
        self.y_cod = y

    def __str__(self):
        return '<{},{}>'.format(self.x_cod,self.y_cod)

    def euclidian_distance(self,other):
        return ((self.x_cod - other.x_cod)**2  +  ((self.y_cod - other.y_cod)**2))**0.5

    def distance_from_origin(self):
        return self.euclidian_distance(Point(0,0))

class Line:
    def __init__(self,A,B,C):
        self.A = A
        self.B = B
        self.C = C

    def __str__(self):
        return '{}x + {}y + {}'.format(self.A,self.B,self.C)

    def lies_on_line(line,point):
        if line.A*point.x_cod + line.B*point.y_cod + line.C == 0:
            return 'Lies on the line'

        else:
            return "Don't lies on the line"


    def dist_btw_pt_line(line,point):
        return abs(line.A*point.x_cod + line.B*point.y_cod + line.C)/(line.A**2 + line.B**2)

#Create and view 2d coordinate

p1 = Point(10,0)
#<2,3>
print(p1)

p2 = Point(10,10)
print(p2)



#calculate distance between two points

p1.euclidian_distance(p2)



#Calculate distance between point and origin

p3 = Point(0,0)

p3.distance_from_origin()



#Check point lies on line or not

l1 = Line(3,4,5)

print(l1)
#3x + 4y + 5



#Lies on the line or not

l1 = Line(1,1,-2)
p2 = Point(1,2)
print(l1)
print(p2)

l1.lies_on_line(p2)



#* objName.methodName()
#indirectly passsing that object in that method no neeed to explicitly send objects

#Shortest distance between line and point:

l= Line(1,1,-2)
p=Point(1,2)

l.dist_btw_pt_line(p)



##HW] Two lines intersect or not





"""## How attributes(data) and methods accesed by object"""

class Hotel:
    def __init__(self,name,country):
        self.name = name
        self.country = country

    def greet(self):
        if self.country == 'india':
            return 'namaste {}'.format(self.name)
        else:
            return 'welcome {}'.format(self.name)

h= Hotel('Raj','india')
h1 = Hotel('David','australia')

# Calling Attribute

h.name

h.country

#Calling method

h.greet()

h1.greet()

#creating attribute from outside of class

h.gender

h.gender = 'male'

h.gender

##OOps power:
# 1]Create your own data type
# 2]Siplyfies big projects
# 3]real world to software



"""## Referance varaibles"""

# a = ClaaName()

# what is a?
# --> we genarlly call it as a object but technically it is referance varaible.
# -->we can create multiple referance varaible.
# --> ClassName() -> this is real object and we are storing its address or reference in varaible (a) that why it is known as reference varaible.
# -->changes made by one referance varaible apppies for all others.

class Person:
    def __init__(self,name):
        self.name=name

a = Person('raj')
b = a

print(id(b))
print(id(a))

print(a.name)
print(b.name)
b.name = 'vardhan'
print(a.name)
print(b.name)



#Casal method -> class ko likhne ka technique -> ex].RajName
#class daiagram bhi kuch hota hain



"""## Pass by referance"""

#passing obj as a input to function not method -> real me hum refernace/addres bhejte hain not an obj
#a function returning a obj

class Person:
    def __init__(self,name,gender):
        self.name = name
        self.gender = gender


def greet(self):
    print("Hi my name is",self.name,"and i am ",self.gender)
    p1 = Person('king','mer')
    return p1

d = Person('Raj','male')

print(d)

p1 = greet(d)

print(p1.name)

print(id(d))
print(id(p1))



"""## Object mutability"""

# Objects are mutable

class Person:
    def __init__(self,name,gender):
        self.name = name
        self.gender = gender


def greet(self):
    print("Hi my name is",self.name,"and i am ",self.gender)
    self.name="vardhan"
    return self

p = Person("raj","male")

self = greet(p)

id(p)

id(self)

p.name



"""## Encapsulation"""

#Instance varaibles
# value of instance varaibles is different for each object

class Person:
    def __init__(self,name,gender): #name and gender are instamce varaibles
        self.name = name
        self.gender = gender

p1 = Person('raj','male')
p2 = Person('vardhan','male')

p1.name

p2.name

id(p1)

id(p2)



#
# all attributes in class should br private ->good practice
# how to make attributes private -> __attributeName
#Python is for adults not for childs
# jaha bhi sttribute use hor raha hain vo __attributeName isi name se use hoga!
#how private varaibles stored in memeory -> _className__AttributrNmes
#Junior senior programmer ki kahani

#Why to make varaibles private -> so that no one able to change values of attributes/infact . marne ke bad aaapo suggetion me bhi vo private varaible dikhai nahi dega
# ObjName._ClassName__AttributeNmae = 'new value' -> privete varaible ka value change hoga
#Their is nothing truly private in python
#To ky fayda python ke private ka --> python is for adult not for kids

# Aise to kisi ko bhi us varaible ka value nahi dikhega agar kisis jnior ko chahiye hi hoga to kya karoge:
#use getter and setter
#private rehte hue use private attribute ka value get and set karna
#obj nahi access kar sakta private attribute ko diretly, magar obj method aacess kar sakta hain and usse vo private wala attribute bhi acess ho sakta hain

class Person:
    def __init__(self,name,bal): #name and gender are instamce varaibles
        self.name = name
        self.__bal = bal

    def get_bal(self):
        return self.__bal

    def set_bal(self,new_val):
        if type(new_val)==int:
            self.__bal=new_val
        else:
            print("Beta bahut marenge")

p = Person("King",1000)

p.get_bal()

p.set_bal(20000)

p.set_bal('hehehe')

p.get_bal()

#You can't access private attributes outside the classs
#whrn you have to use it always use like self.__name

p.__bal='kya be'

p.__bal

p.get_bal()



#You can wrap up objects into list/set and treat as normal list or dictionary



"""## Instance vs static"""

# 1] Instance varaible is varaible of obj
#  static varaible is varaible of class

# 2]Instance varaibles's value is different for each obj
#  static varaibles's value is same for each obj

# 3] Instance varaible declered inside constructor
#  local varaible declered outside all method inside class

# 4] Instance varaible Declered using objname.varaiblename
#    static varaible Declered using classname.varaiblename


#Check application then decide which is instance and which is ststic

class Atm:

  __counter = 1

  # constructor(special function)->superpower ->
  def __init__(self):
    print(id(self))
    self.pin = ''
    self.__balance = 0
    self.cid = Atm.__counter
    Atm.__counter = Atm.__counter + 1
    #self.menu()

  # utility functions
  @staticmethod
  def get_counter():
    return Atm.__counter


  def get_balance(self):
    return self.__balance

  def set_balance(self,new_value):
    if type(new_value) == int:
      self.__balance = new_value
    else:
      print('beta bahot maarenge')

  def __menu(self):
    user_input = input("""
    Hi how can I help you?
    1. Press 1 to create pin
    2. Press 2 to change pin
    3. Press 3 to check balance
    4. Press 4 to withdraw
    5. Anything else to exit
    """)

    if user_input == '1':
      self.create_pin()
    elif user_input == '2':
      self.change_pin()
    elif user_input == '3':
      self.check_balance()
    elif user_input == '4':
      self.withdraw()
    else:
      exit()

  def create_pin(self):
    user_pin = input('enter your pin')
    self.pin = user_pin

    user_balance = int(input('enter balance'))
    self.__balance = user_balance

    print('pin created successfully')

  def change_pin(self):
    old_pin = input('enter old pin')

    if old_pin == self.pin:
      # let him change the pin
      new_pin = input('enter new pin')
      self.pin = new_pin
      print('pin change successful')
    else:
      print('nai karne de sakta re baba')

  def check_balance(self):
    user_pin = input('enter your pin')
    if user_pin == self.pin:
      print('your balance is ',self.__balance)
    else:
      print('chal nikal yahan se')

  def withdraw(self):
    user_pin = input('enter the pin')
    if user_pin == self.pin:
      # allow to withdraw
      amount = int(input('enter the amount'))
      if amount <= self.__balance:
        self.__balance = self.__balance - amount
        print('withdrawl successful.balance is',self.__balance)
      else:
        print('abe garib')
    else:
      print('sale chor')

c1 = Atm()

Atm.get_counter()

c3 = Atm()

c3.cid

# Atm.counter # it is private



"""## Static method"""

#Decorater = @staticmethod
#obj ki need nahi hoti
#utility function ke liye use kiya jata hain
# ststic varaibles ke liye vo pura instance varible ka privtate wala logic apply hota haian
# attribute = getter and setter

class Lion:
  __water_source="well in the circus"

  def __init__(self,name, gender):
      self.__name=name
      self.__gender=gender

  def drinks_water(self):
      print(self.__name,
      "drinks water from the",Lion.__water_source)

  @staticmethod
  def get_water_source():
      return Lion.__water_source

simba=Lion("Simba","Male")
simba.drinks_water()
print( "Water source of lions:",Lion.get_water_source())

# ##### Points to remember about static

# - Static attributes are created at class level.
# - Static attributes are accessed using ClassName.
# - Static attributes are object independent. We can access them without creating instance (object) of the class in which they are defined.
# - The value stored in static attribute is shared between all instances(objects) of the class in which the static attribute is defined.

