# -*- coding: utf-8 -*-
"""13_Recursion ,Iterators and Genrators.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TC-feYqxLYQ_249Rhcop7eBe1bKw4yd3

## Recursion:
"""

#functions call itself
#don't need loop -> looked as replacement of loop
#famous in industry for good and bad reasond:
# 1.Good = people feel proud beacuse they know and use recursion -> recursion is bit a difficult topic
# 2.Bad -> frequently use nahi karte ho -> inefficient code hota hain rcursion ka

# recursion may be implemented using stack
#python tutor
#niche jata hain fir niche se upar aata hain ->python tutor

#Ex]
#using iterative(loop)

def multiply(a, b):
    result = 0

    for i in range(b):
        result = result + a

    print(result)

multiply(4, 4)

# recursive solution

# Need two things
# 1.Base condition(can say aisi condition jiska ans aapko pehle se pata hain(must))
# 2.Decompose the problem into small problem

def mul(a, b):
    if b == 1:
        return a
    else:
        return a + mul(a, b - 1)

print(mul(5, 8))

# factorial

def fact(number):
    if number == 1:
        return 1
    else:
        # 5! = 5 * 4!
        return number * fact(number - 1)

print(fact(4))

import math
fact(5)

# palindrome

def palin(text):
    if len(text) <= 1:
        print("palindrome")
    else:
        if text[0] == text[-1]:
            palin(text[1:-1])
        else:
            print("Not a palin")

a = input("Enter string")
palin(a)

# rabbits problem = fibonacci series

def fib(mon):
  if mon == 0 or mon == 1:
    return 1

  else :
    return fib(mon-1) + fib(mon-2)

print(fib(10))

# problem inefficient code
# exponential curve

# solution: dp ko use karo
# momoization(dp) -> har bar us particular number ka fibonacci kyu nikalna ,ek bar nikalo use store karo and badme use karo!
# time ghatata hain but spce badhta hain!
# dp = time and space tradeoff

# efficient solution:

import time
def memo(m, d):

    if m in d:
        return d[m]
    else:
        d[m] = memo(m-1, d) + memo(m-2, d)
        return d[m]

start = time.time()
d = {0: 1, 1: 1}
print(memo(12, d))
print(time.time() - start)
print(d)

# generate poer set



"""## Iterator:"""

# What is an Iteration

# Iteration is a general term for taking each item of something, one after another.
# Any time you use a loop, explicit or implicit, to go over a group of items, that is iteration.

# The process of traversing items in iterable
# traverse -> har ek item ko fetxh karke uske upar kuch operation karna.

# Example
num = [1,2,3]

for i in num:
    print(i)

# What is Iterator

# An Iterator is an object that allows the programmer to traverse through a sequence of data without having to store the entire data in the memory

# which iterates on iterable and perform iteration process.
# ye vahi hain jo har ek item ko fethc karta hain and uske upar kuch operation perform karta hain.

# Example
L = [x for x in range(1,10000)]

#for i in L:
    #print(i*2)

import sys

print(sys.getsizeof(L)/64)

x = range(1,10000000000)

#for i in x:
    #print(i*2)

print(sys.getsizeof(x)/64)

# What is Iterable
# Iterable is an object, which one can iterate over
#  It generates an Iterator when passed to iter() method.

# jiske upar iterator iterate karta hain!

# iteration = process
# iterator = jo kam(iteration ka) karata hain
# iterable = jiske upar kam hota hain

# Example

L = [1,2,3]
print(type(L))


# L is an iterable
type(iter(L))

# iter(L) --> iterator



## Point to remember

# - Every **Iterator** is also and **Iterable**
# - Not all **Iterables** are **Iterators**



# ## Trick
# - Every Iterable has an **iter function**
# - Every Iterator has both **iter function** as well as a **next function**

a = 2
a

#for i in a:
    #print(i)

dir(a)
#not an iterable

# iterable
T = {1:2,3:4}
dir(T)

# iterable

# iterable hain ya nahi ?
#-->
#1.agar uspe loop chala skate ho ,to vo iterable hain else nahi hain
#2.uske pass sirf iter method hoga

L = [1,2,3]

# L is not an iterator
iter_L = iter(L)

# iter_L is an iterator

# iterator

# iterator hain ya nahi ?
#-->
#1.uske pass  iter and next  method hoga



# how loop works

num = [1,2,3]

for i in num:
    print(i)

#real me ye hota hain
num = [1,2,3]

# fetch the iterator
iter_num = iter(num)

# step2 --> next
next(iter_num)
next(iter_num)
next(iter_num)
# next(iter_num)

# making our own for loop

def mera_khudka_for_loop(iterable):

    iterator = iter(iterable)

    while True:

        try:
            print(next(iterator))
        except StopIteration:
            break

a = [1,2,3]
b = range(1,11)
c = (1,2,3)
d = {1,2,3}
e = {0:1,1:1}

mera_khudka_for_loop(e)



# Confusing Point

num = [1,2,3]
iter_obj = iter(num)

print(id(iter_obj),'Address of iterator 1')

iter_obj2 = iter(iter_obj)
print(id(iter_obj2),'Address of iterator 2')

# jab ek itearble ke iterator pe iter chalta hain tab vo palat ek ek naya iterator deta hain jo ki vo prana iterator khud hi hota hain.
# gangadhar hi shaktiman hain.
# iterable(obj) ke upar loop chalne me use kiya jata hain



# our own range function

class mera_range:

    def __init__(self,start,end):
        self.start = start
        self.end = end

    def __iter__(self):
        return mera_range_iterator(self)

class mera_range_iterator:

    def __init__(self,iterable_obj):
        self.iterable = iterable_obj

    def __iter__(self):
        return self

    def __next__(self):

        if self.iterable.start >= self.iterable.end:
            raise StopIteration

        current = self.iterable.start
        self.iterable.start+=1
        return current

for i in mera_range(1,11):
  print(i)



#  iterator eb bar ek hi item ko load karta hain , vo pure data ko load nahi karta yahi uska sabse bada poere hain



"""## Genrators"""

# ## What is a Generator

#Python generators are a simple way of creating iterators.

# why

L = [x for x in range(100000)]

#for i in L:
    #print(i**2)

import sys
sys.getsizeof(L)

x = range(10000000)

#for i in x:
    #print(i**2)
sys.getsizeof(x)

# simple example

def gen_demo():

    yield "first statement"
    yield "second statement"
    yield "third statement"

gen = gen_demo()

for i in gen:
    print(i)

# diff b/w return and yield

def square(num):
    for i in range(1,num+1):
        yield i**2

gen = square(10)

print(next(gen))
print(next(gen))
print(next(gen))

for i in gen:
    print(i)

# rabge using generator
def mera_range(start,end):

    for i in range(start,end):
        yield i

for i in mera_range(15,26):
    print(i)

# generator expression
# same as list comprehension

gen = (i**2 for i in range(1,101))

for i in gen:
    print(i)

# practical example

import os
import cv2

def image_data_reader(folder_path):

    for file in os.listdir(folder_path):
        f_array = cv2.imread(os.path.join(folder_path,file))
        yield f_array


gen = image_data_reader('C:/Users/91842/emotion-detector/train/Sad')

next(gen)
next(gen)

next(gen)

# genrator -> easy way to create iterator
# why use iterator -> memory reason
# return -> kam khatam hone ke bad chala jata hain . yield -> kam hone ke bad bhi rehta hain
# to eecute genator eithe use loop or next method

# benifits
# 1. Ease of Implementation
# before
class mera_range:

    def __init__(self,start,end):
        self.start = start
        self.end = end

    def __iter__(self):
        return mera_range_iterator(self)

class mera_range_iterator:

    def __init__(self,iterable_obj):
        self.iterable = iterable_obj

    def __iter__(self):
        return self

    def __next__(self):

        if self.iterable.start >= self.iterable.end:
            raise StopIteration

        current = self.iterable.start
        self.iterable.start+=1
        return current

for i in mera_range(1,11):
  print(i)

  #after
 def mera_range(start,end):

    for i in range(start,end):
        yield i


# 2. Memory Efficient
L = [x for x in range(100000)]
gen = (x for x in range(100000))

import sys

print('Size of L in memory',sys.getsizeof(L))
print('Size of gen in memory',sys.getsizeof(gen))


# 3. Representing Infinite Streams
def all_even():
    n = 0
    while True:
        yield n
        n += 2
even_num_gen = all_even()
next(even_num_gen)
next(even_num_gen)


# 4. Chaining Generators

def fibonacci_numbers(nums):
    x, y = 0, 1
    for _ in range(nums):
        x, y = y, x+y
        yield x

def square(nums):
    for num in nums:
        yield num**2

print(sum(square(fibonacci_numbers(10))))